/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "RooDoubleSidedCB.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

ClassImp(RooDoubleSidedCB) 

 RooDoubleSidedCB::RooDoubleSidedCB(const char *name, const char *title, 
                        RooAbsReal& _m,
                        RooAbsReal& _m0,
                        RooAbsReal& _sigma,
                        RooAbsReal& _alpha_L,
                        RooAbsReal& _n_L,
                        RooAbsReal& _alpha_R,
                        RooAbsReal& _n_R) :
   RooAbsPdf(name,title), 
   m("m","m",this,_m),
   m0("m0","m0",this,_m0),
   sigma("sigma","sigma",this,_sigma),
   alpha_L("alpha_L","alpha_L",this,_alpha_L),
   n_L("n_L","n_L",this,_n_L),
   alpha_R("alpha_R","alpha_R",this,_alpha_R),
   n_R("n_R","n_R",this,_n_R)
 { 
 } 


 RooDoubleSidedCB::RooDoubleSidedCB(const RooDoubleSidedCB& other, const char* name) :  
   RooAbsPdf(other,name), 
   m("m",this,other.m),
   m0("m0",this,other.m0),
   sigma("sigma",this,other.sigma),
   alpha_L("alpha_L",this,other.alpha_L),
   n_L("n_L",this,other.n_L),
   alpha_R("alpha_R",this,other.alpha_R),
   n_R("n_R",this,other.n_R)
 { 
 } 


 Double_t RooDoubleSidedCB::evaluate() const 
 { 
   // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 

   Double_t t = (m-m0)/sigma;
   
   if (alpha_L < 0 ) t = -t;
   
   Double_t absAlpha_R = fabs((Double_t)alpha_R);
   Double_t absAlpha_L = fabs((Double_t)alpha_L);
   
   if (t < -absAlpha_L) {
     Double_t a_L =  TMath::Power(n_L/absAlpha_L,n_L)*exp(-0.5*absAlpha_L*absAlpha_L);
     Double_t b_L = n_L/absAlpha_L - absAlpha_L; 
     return a_L/TMath::Power(b_L - t, n_L); 
   }       
   
   else if(t > absAlpha_R){
     Double_t a_R =  TMath::Power(n_R/absAlpha_R,n_R)*exp(-0.5*absAlpha_R*absAlpha_R);
     Double_t b_R = n_R/absAlpha_R - absAlpha_R; 
     return a_R/TMath::Power(b_R - t, n_R); 
   } 
   
   else {
     return exp(-0.5*t*t);
   }
 
 }



